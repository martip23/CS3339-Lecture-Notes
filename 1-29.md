# ISA

## Review
* Supercomputers
* Performance Metrics
	* CPI
	* CPU Execution Time
	* Throughput for OS 
		* Tasks per unit of time
	* Latency(ping) vs bandwidth(kbps)
* Amdahl's Law
	* Benefit depends on amount of times optimization are used

## ISA Layer (bewteen OS and micro-architecture)

### What is an ISA?
* Instruction Set Architecture
	* Description of Assembly Language
* For programmer
	* ISA is a model of how program will execute
* For hardware Designer
	* ISA is a formal definition of the correct way to execute a program.

### ISA vs Architecture vs Implementation
* ISA - Description/Contract for compiler writer
* x86 variants can be thought of "inheriting" from x86

### ISA & Implementations
* MIPS, x86, IBM 360, JVM
* Implementations
	* 8086, Pentium, Pentium Pro, Pentium-4, AMD Athlon
	* MIPS implementations: R2000, R4000, R10000

### Classification based on Computation Model

#### Accumulator

* Only instruction it executes is add function
* Not great performance
* Code generation difficult
* Large code size

#### Stack

* A stack machine has a stack as part of the processor state
* Push, pop, * , + ...
* Instructions like '+' implicitly
* Top 2 elements of stack as operands

#### General Purpose Registers
* Memory <--> Registers <-----> CPU
* Uses control unit which fetches instructions from ONLY memory. (main, and so on)
* If it's ALU, assigns ALU to task, etc. 
* Systems have multiple ALUs. ALUs and Control unit are grouped together.
* To get data from memory send LOAD instruction or STORE to store.
* CISC will allow memory -> ALU instruction (bypassing registers)

### Why Study ISA?
* We want to understand differences
* Learn about issues in designing good ISAs
* Evaluate system based on ISA

### ISA design goals
* Machine state -> INSTRUCTION -> Machine State
* How does instruction affect machine state?

#### Machine State
* Registers (size/type)
* Memory (Variable hierarchy, Addressability, Protection/relocation)
* Program Counter or Instruction Pointer

#### Instruction Classes

* What do you need? Instructions can be grouped in three classes.
	* ALU operations (+, -, *, /)
	* Control Flow (Branching statements)
		* Conditional Jump - (branch) Jump based on condition
		* Jump (unconditional)
		* Implemented by manipulating program counter
	* Data Movement (Assignment, In/Out)
		* Store, Load, Move (less common)
		* (Store always sends to memory, Load into register)

## Instruction Encoding
* Assembly vs Machines
	* Assembly
		* Readable
		* Associated with architecture
		* x86 Assembly
	* Machine Code
		* Machine readable
		* Tied to specific hardware
		* Machine code for Opteron
* C compilation
	* C -> Compiler -> assembly -> assembler -> Object Code -> linker (libraries) -> executable -> loader -> memory

